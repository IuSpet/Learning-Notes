# 搜索算法

### 主要分类

- 深度优先搜索
- 广度优先搜索
- A*搜索
- IDA*

### 深度优先搜索（DFS）

​		在每个节点处，如果这个节点还能向下延伸，就先继续处理延伸出的下个节点，而不管当前节点的兄弟节点，即父节点延伸出的其他情况。在每次调用dfs()语句后面可以恢复状态进行回溯

```c++
void dfs(){
	if (can continue)
	{
		a++;
		dfs();
		a--;	//回溯
	}
}
```

##### 适用问题：

- 涂色

### 广度优先搜索（BFS）

​		从父节点开始，优先处理每一层的所有节点，处理完再处理下一层的所有节点，用队列实现

```cpp
void bfs()
{
    queue<node> q;
    q.push(start);
    while(!q.empty())
    {
        node index = q.front(); q.pop();
        node tmp;
        /*
            ......
            由index计算出新的节点
            ......
        */
        //每次入队要判重，不然空间很容易爆
        if(!vis[tmp])
        {
            //找到答案后，记录答案，退出
            if(tmp == ans) break;
            vis[tmp] = true;
            //新的节点入队
            q.push(tmp);          
        }
    }
}
```

##### 适用问题：

- 最短路

### 迭代加深搜索（IDA\*）

​		以上几种算法，DFS容易过度搜索，耗费大量时间空间；BFS耗费空间极大；A*作为升级版的BFS，也有同样问题，IDA\*结合了以上算法，对各个算法的缺点有一定弥补。

​		IDA*在指定搜索深度的情况下使用DFS进行搜索，如果没有找到答案就加深搜索深度