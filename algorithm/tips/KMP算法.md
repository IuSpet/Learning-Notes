# KMP算法

### 介绍：

​		O(m+n)复杂度的字符串匹配算法

### 输入：

匹配串：char T[m]

模式串：char  P[n]

### 输出：

模式串P的next数组：int next[n]

匹配函数应用next数组进行匹配，修改代码，可以计算各次匹配位置，最多匹配次数等

### 思路：

​		模式串在匹配匹配串的过程中，在从匹配串第 $i$ 位开始匹配，匹配到第 $i+k$ ($k>0$) 位失败时，对于朴素字符串匹配算法，会接着从 $i+1$ 位开始匹配；而KMP算法的思想是，虽然在第 $k$ 位失败了，但是也**知道了匹配串 $\left[ i,i+k-1 \right]$ 位的内容**，这一段和模式串的 $\left[ 0,k-1 \right]$ 位相同。从 $i+1$ 位重新开始匹配，就等价于模式串的第 $0$ 位和第 $1$ 位进行匹配，而这一匹配的结果是可以**提前从模式串自身得知**的，类似的可以提前得知自身 $\left[ 0,k-1 \right]$ 位自身和自身匹配的最好结果，即该部分前缀后缀相同的最长长度 $next[k]$，利用该信息，模式串就可以从匹配串的第 $i+k$ 位重新开始匹配，此时已匹配长度为 $next[k]$，匹配串第 $next[k]$ 位和模式串第 $i+k$ 位进行比较匹配，重复上述过程完成匹配。

​		**用一句话描述，就是利用模式串自身的信息，在匹配失败时，用匹配过的部分指导接下来的匹配**

> 此部分的复杂度为 O(m)

​		从前面的描述中不难看出 next 数组的意义，next[k] 代表模式串前 $k$ 位前缀和后缀匹配的最大长度，计算过程为

- $next[0]$, $next[1]$显然为0
- 对于next[i]，令 $j$ 等于next[i-1]，$j$ 就是前 $i-1$ 位的最大匹j配长度；另一层含义是，前 $i-1$ 位的前缀匹配到了 P[j-1]，在 next[i-1]的基础上
- 比较P[i]和P[j]
  - 如果相同，那么 $next[i] = j + 1$
  - 如果不同，且 $j\neq0$ ，参考KMP匹配的过程，此时相当于长度 $j+1$ 的模式串匹配到模式串的第 $j$ 位失败了，所以令 $j=next[j]$ 回到第三步重复此步骤
  - 如果不同，且 $j=0$ ，那么 $next[i] = 0$
> 此部分的复杂度为 O(n)

### 代码（C++）：

##### 获取next数组

```

```

